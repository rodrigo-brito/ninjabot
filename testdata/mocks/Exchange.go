// Code generated by mockery v2.15.0. DO NOT EDIT.

package mocks

import (
	context "context"

	model "github.com/rodrigo-brito/ninjabot/model"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// Exchange is an autogenerated mock type for the Exchange type
type Exchange struct {
	mock.Mock
}

type Exchange_Expecter struct {
	mock *mock.Mock
}

func (_m *Exchange) EXPECT() *Exchange_Expecter {
	return &Exchange_Expecter{mock: &_m.Mock}
}

// Account provides a mock function with given fields:
func (_m *Exchange) Account() (model.Account, error) {
	ret := _m.Called()

	var r0 model.Account
	if rf, ok := ret.Get(0).(func() model.Account); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(model.Account)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exchange_Account_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Account'
type Exchange_Account_Call struct {
	*mock.Call
}

// Account is a helper method to define mock.On call
func (_e *Exchange_Expecter) Account() *Exchange_Account_Call {
	return &Exchange_Account_Call{Call: _e.mock.On("Account")}
}

func (_c *Exchange_Account_Call) Run(run func()) *Exchange_Account_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Exchange_Account_Call) Return(_a0 model.Account, _a1 error) *Exchange_Account_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// AssetsInfo provides a mock function with given fields: pair
func (_m *Exchange) AssetsInfo(pair string) model.AssetInfo {
	ret := _m.Called(pair)

	var r0 model.AssetInfo
	if rf, ok := ret.Get(0).(func(string) model.AssetInfo); ok {
		r0 = rf(pair)
	} else {
		r0 = ret.Get(0).(model.AssetInfo)
	}

	return r0
}

// Exchange_AssetsInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssetsInfo'
type Exchange_AssetsInfo_Call struct {
	*mock.Call
}

// AssetsInfo is a helper method to define mock.On call
//   - pair string
func (_e *Exchange_Expecter) AssetsInfo(pair interface{}) *Exchange_AssetsInfo_Call {
	return &Exchange_AssetsInfo_Call{Call: _e.mock.On("AssetsInfo", pair)}
}

func (_c *Exchange_AssetsInfo_Call) Run(run func(pair string)) *Exchange_AssetsInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Exchange_AssetsInfo_Call) Return(_a0 model.AssetInfo) *Exchange_AssetsInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

// Cancel provides a mock function with given fields: _a0
func (_m *Exchange) Cancel(_a0 model.Order) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(model.Order) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Exchange_Cancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cancel'
type Exchange_Cancel_Call struct {
	*mock.Call
}

// Cancel is a helper method to define mock.On call
//   - _a0 model.Order
func (_e *Exchange_Expecter) Cancel(_a0 interface{}) *Exchange_Cancel_Call {
	return &Exchange_Cancel_Call{Call: _e.mock.On("Cancel", _a0)}
}

func (_c *Exchange_Cancel_Call) Run(run func(_a0 model.Order)) *Exchange_Cancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Order))
	})
	return _c
}

func (_c *Exchange_Cancel_Call) Return(_a0 error) *Exchange_Cancel_Call {
	_c.Call.Return(_a0)
	return _c
}

// CandlesByLimit provides a mock function with given fields: ctx, pair, period, limit
func (_m *Exchange) CandlesByLimit(ctx context.Context, pair string, period string, limit int) ([]model.Candle, error) {
	ret := _m.Called(ctx, pair, period, limit)

	var r0 []model.Candle
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) []model.Candle); ok {
		r0 = rf(ctx, pair, period, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Candle)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, int) error); ok {
		r1 = rf(ctx, pair, period, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exchange_CandlesByLimit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CandlesByLimit'
type Exchange_CandlesByLimit_Call struct {
	*mock.Call
}

// CandlesByLimit is a helper method to define mock.On call
//   - ctx context.Context
//   - pair string
//   - period string
//   - limit int
func (_e *Exchange_Expecter) CandlesByLimit(ctx interface{}, pair interface{}, period interface{}, limit interface{}) *Exchange_CandlesByLimit_Call {
	return &Exchange_CandlesByLimit_Call{Call: _e.mock.On("CandlesByLimit", ctx, pair, period, limit)}
}

func (_c *Exchange_CandlesByLimit_Call) Run(run func(ctx context.Context, pair string, period string, limit int)) *Exchange_CandlesByLimit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *Exchange_CandlesByLimit_Call) Return(_a0 []model.Candle, _a1 error) *Exchange_CandlesByLimit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CandlesByPeriod provides a mock function with given fields: ctx, pair, period, start, end
func (_m *Exchange) CandlesByPeriod(ctx context.Context, pair string, period string, start time.Time, end time.Time) ([]model.Candle, error) {
	ret := _m.Called(ctx, pair, period, start, end)

	var r0 []model.Candle
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Time, time.Time) []model.Candle); ok {
		r0 = rf(ctx, pair, period, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Candle)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, time.Time, time.Time) error); ok {
		r1 = rf(ctx, pair, period, start, end)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exchange_CandlesByPeriod_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CandlesByPeriod'
type Exchange_CandlesByPeriod_Call struct {
	*mock.Call
}

// CandlesByPeriod is a helper method to define mock.On call
//   - ctx context.Context
//   - pair string
//   - period string
//   - start time.Time
//   - end time.Time
func (_e *Exchange_Expecter) CandlesByPeriod(ctx interface{}, pair interface{}, period interface{}, start interface{}, end interface{}) *Exchange_CandlesByPeriod_Call {
	return &Exchange_CandlesByPeriod_Call{Call: _e.mock.On("CandlesByPeriod", ctx, pair, period, start, end)}
}

func (_c *Exchange_CandlesByPeriod_Call) Run(run func(ctx context.Context, pair string, period string, start time.Time, end time.Time)) *Exchange_CandlesByPeriod_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Time), args[4].(time.Time))
	})
	return _c
}

func (_c *Exchange_CandlesByPeriod_Call) Return(_a0 []model.Candle, _a1 error) *Exchange_CandlesByPeriod_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CandlesSubscription provides a mock function with given fields: ctx, pair, timeframe
func (_m *Exchange) CandlesSubscription(ctx context.Context, pair string, timeframe string) (chan model.Candle, chan error) {
	ret := _m.Called(ctx, pair, timeframe)

	var r0 chan model.Candle
	if rf, ok := ret.Get(0).(func(context.Context, string, string) chan model.Candle); ok {
		r0 = rf(ctx, pair, timeframe)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan model.Candle)
		}
	}

	var r1 chan error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) chan error); ok {
		r1 = rf(ctx, pair, timeframe)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(chan error)
		}
	}

	return r0, r1
}

// Exchange_CandlesSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CandlesSubscription'
type Exchange_CandlesSubscription_Call struct {
	*mock.Call
}

// CandlesSubscription is a helper method to define mock.On call
//   - ctx context.Context
//   - pair string
//   - timeframe string
func (_e *Exchange_Expecter) CandlesSubscription(ctx interface{}, pair interface{}, timeframe interface{}) *Exchange_CandlesSubscription_Call {
	return &Exchange_CandlesSubscription_Call{Call: _e.mock.On("CandlesSubscription", ctx, pair, timeframe)}
}

func (_c *Exchange_CandlesSubscription_Call) Run(run func(ctx context.Context, pair string, timeframe string)) *Exchange_CandlesSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Exchange_CandlesSubscription_Call) Return(_a0 chan model.Candle, _a1 chan error) *Exchange_CandlesSubscription_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CreateOrderLimit provides a mock function with given fields: side, pair, size, limit
func (_m *Exchange) CreateOrderLimit(side model.SideType, pair string, size float64, limit float64) (model.Order, error) {
	ret := _m.Called(side, pair, size, limit)

	var r0 model.Order
	if rf, ok := ret.Get(0).(func(model.SideType, string, float64, float64) model.Order); ok {
		r0 = rf(side, pair, size, limit)
	} else {
		r0 = ret.Get(0).(model.Order)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(model.SideType, string, float64, float64) error); ok {
		r1 = rf(side, pair, size, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exchange_CreateOrderLimit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrderLimit'
type Exchange_CreateOrderLimit_Call struct {
	*mock.Call
}

// CreateOrderLimit is a helper method to define mock.On call
//   - side model.SideType
//   - pair string
//   - size float64
//   - limit float64
func (_e *Exchange_Expecter) CreateOrderLimit(side interface{}, pair interface{}, size interface{}, limit interface{}) *Exchange_CreateOrderLimit_Call {
	return &Exchange_CreateOrderLimit_Call{Call: _e.mock.On("CreateOrderLimit", side, pair, size, limit)}
}

func (_c *Exchange_CreateOrderLimit_Call) Run(run func(side model.SideType, pair string, size float64, limit float64)) *Exchange_CreateOrderLimit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.SideType), args[1].(string), args[2].(float64), args[3].(float64))
	})
	return _c
}

func (_c *Exchange_CreateOrderLimit_Call) Return(_a0 model.Order, _a1 error) *Exchange_CreateOrderLimit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CreateOrderMarket provides a mock function with given fields: side, pair, size
func (_m *Exchange) CreateOrderMarket(side model.SideType, pair string, size float64) (model.Order, error) {
	ret := _m.Called(side, pair, size)

	var r0 model.Order
	if rf, ok := ret.Get(0).(func(model.SideType, string, float64) model.Order); ok {
		r0 = rf(side, pair, size)
	} else {
		r0 = ret.Get(0).(model.Order)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(model.SideType, string, float64) error); ok {
		r1 = rf(side, pair, size)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exchange_CreateOrderMarket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrderMarket'
type Exchange_CreateOrderMarket_Call struct {
	*mock.Call
}

// CreateOrderMarket is a helper method to define mock.On call
//   - side model.SideType
//   - pair string
//   - size float64
func (_e *Exchange_Expecter) CreateOrderMarket(side interface{}, pair interface{}, size interface{}) *Exchange_CreateOrderMarket_Call {
	return &Exchange_CreateOrderMarket_Call{Call: _e.mock.On("CreateOrderMarket", side, pair, size)}
}

func (_c *Exchange_CreateOrderMarket_Call) Run(run func(side model.SideType, pair string, size float64)) *Exchange_CreateOrderMarket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.SideType), args[1].(string), args[2].(float64))
	})
	return _c
}

func (_c *Exchange_CreateOrderMarket_Call) Return(_a0 model.Order, _a1 error) *Exchange_CreateOrderMarket_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CreateOrderMarketQuote provides a mock function with given fields: side, pair, quote
func (_m *Exchange) CreateOrderMarketQuote(side model.SideType, pair string, quote float64) (model.Order, error) {
	ret := _m.Called(side, pair, quote)

	var r0 model.Order
	if rf, ok := ret.Get(0).(func(model.SideType, string, float64) model.Order); ok {
		r0 = rf(side, pair, quote)
	} else {
		r0 = ret.Get(0).(model.Order)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(model.SideType, string, float64) error); ok {
		r1 = rf(side, pair, quote)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exchange_CreateOrderMarketQuote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrderMarketQuote'
type Exchange_CreateOrderMarketQuote_Call struct {
	*mock.Call
}

// CreateOrderMarketQuote is a helper method to define mock.On call
//   - side model.SideType
//   - pair string
//   - quote float64
func (_e *Exchange_Expecter) CreateOrderMarketQuote(side interface{}, pair interface{}, quote interface{}) *Exchange_CreateOrderMarketQuote_Call {
	return &Exchange_CreateOrderMarketQuote_Call{Call: _e.mock.On("CreateOrderMarketQuote", side, pair, quote)}
}

func (_c *Exchange_CreateOrderMarketQuote_Call) Run(run func(side model.SideType, pair string, quote float64)) *Exchange_CreateOrderMarketQuote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.SideType), args[1].(string), args[2].(float64))
	})
	return _c
}

func (_c *Exchange_CreateOrderMarketQuote_Call) Return(_a0 model.Order, _a1 error) *Exchange_CreateOrderMarketQuote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CreateOrderOCO provides a mock function with given fields: side, pair, size, price, stop, stopLimit
func (_m *Exchange) CreateOrderOCO(side model.SideType, pair string, size float64, price float64, stop float64, stopLimit float64) ([]model.Order, error) {
	ret := _m.Called(side, pair, size, price, stop, stopLimit)

	var r0 []model.Order
	if rf, ok := ret.Get(0).(func(model.SideType, string, float64, float64, float64, float64) []model.Order); ok {
		r0 = rf(side, pair, size, price, stop, stopLimit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(model.SideType, string, float64, float64, float64, float64) error); ok {
		r1 = rf(side, pair, size, price, stop, stopLimit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exchange_CreateOrderOCO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrderOCO'
type Exchange_CreateOrderOCO_Call struct {
	*mock.Call
}

// CreateOrderOCO is a helper method to define mock.On call
//   - side model.SideType
//   - pair string
//   - size float64
//   - price float64
//   - stop float64
//   - stopLimit float64
func (_e *Exchange_Expecter) CreateOrderOCO(side interface{}, pair interface{}, size interface{}, price interface{}, stop interface{}, stopLimit interface{}) *Exchange_CreateOrderOCO_Call {
	return &Exchange_CreateOrderOCO_Call{Call: _e.mock.On("CreateOrderOCO", side, pair, size, price, stop, stopLimit)}
}

func (_c *Exchange_CreateOrderOCO_Call) Run(run func(side model.SideType, pair string, size float64, price float64, stop float64, stopLimit float64)) *Exchange_CreateOrderOCO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.SideType), args[1].(string), args[2].(float64), args[3].(float64), args[4].(float64), args[5].(float64))
	})
	return _c
}

func (_c *Exchange_CreateOrderOCO_Call) Return(_a0 []model.Order, _a1 error) *Exchange_CreateOrderOCO_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CreateOrderStop provides a mock function with given fields: pair, quantity, limit
func (_m *Exchange) CreateOrderStop(pair string, quantity float64, limit float64) (model.Order, error) {
	ret := _m.Called(pair, quantity, limit)

	var r0 model.Order
	if rf, ok := ret.Get(0).(func(string, float64, float64) model.Order); ok {
		r0 = rf(pair, quantity, limit)
	} else {
		r0 = ret.Get(0).(model.Order)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, float64, float64) error); ok {
		r1 = rf(pair, quantity, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exchange_CreateOrderStop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrderStop'
type Exchange_CreateOrderStop_Call struct {
	*mock.Call
}

// CreateOrderStop is a helper method to define mock.On call
//   - pair string
//   - quantity float64
//   - limit float64
func (_e *Exchange_Expecter) CreateOrderStop(pair interface{}, quantity interface{}, limit interface{}) *Exchange_CreateOrderStop_Call {
	return &Exchange_CreateOrderStop_Call{Call: _e.mock.On("CreateOrderStop", pair, quantity, limit)}
}

func (_c *Exchange_CreateOrderStop_Call) Run(run func(pair string, quantity float64, limit float64)) *Exchange_CreateOrderStop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64))
	})
	return _c
}

func (_c *Exchange_CreateOrderStop_Call) Return(_a0 model.Order, _a1 error) *Exchange_CreateOrderStop_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// LastQuote provides a mock function with given fields: ctx, pair
func (_m *Exchange) LastQuote(ctx context.Context, pair string) (float64, error) {
	ret := _m.Called(ctx, pair)

	var r0 float64
	if rf, ok := ret.Get(0).(func(context.Context, string) float64); ok {
		r0 = rf(ctx, pair)
	} else {
		r0 = ret.Get(0).(float64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, pair)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exchange_LastQuote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastQuote'
type Exchange_LastQuote_Call struct {
	*mock.Call
}

// LastQuote is a helper method to define mock.On call
//   - ctx context.Context
//   - pair string
func (_e *Exchange_Expecter) LastQuote(ctx interface{}, pair interface{}) *Exchange_LastQuote_Call {
	return &Exchange_LastQuote_Call{Call: _e.mock.On("LastQuote", ctx, pair)}
}

func (_c *Exchange_LastQuote_Call) Run(run func(ctx context.Context, pair string)) *Exchange_LastQuote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Exchange_LastQuote_Call) Return(_a0 float64, _a1 error) *Exchange_LastQuote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// Order provides a mock function with given fields: pair, id
func (_m *Exchange) Order(pair string, id int64) (model.Order, error) {
	ret := _m.Called(pair, id)

	var r0 model.Order
	if rf, ok := ret.Get(0).(func(string, int64) model.Order); ok {
		r0 = rf(pair, id)
	} else {
		r0 = ret.Get(0).(model.Order)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int64) error); ok {
		r1 = rf(pair, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exchange_Order_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Order'
type Exchange_Order_Call struct {
	*mock.Call
}

// Order is a helper method to define mock.On call
//   - pair string
//   - id int64
func (_e *Exchange_Expecter) Order(pair interface{}, id interface{}) *Exchange_Order_Call {
	return &Exchange_Order_Call{Call: _e.mock.On("Order", pair, id)}
}

func (_c *Exchange_Order_Call) Run(run func(pair string, id int64)) *Exchange_Order_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64))
	})
	return _c
}

func (_c *Exchange_Order_Call) Return(_a0 model.Order, _a1 error) *Exchange_Order_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// Position provides a mock function with given fields: pair
func (_m *Exchange) Position(pair string) (float64, float64, error) {
	ret := _m.Called(pair)

	var r0 float64
	if rf, ok := ret.Get(0).(func(string) float64); ok {
		r0 = rf(pair)
	} else {
		r0 = ret.Get(0).(float64)
	}

	var r1 float64
	if rf, ok := ret.Get(1).(func(string) float64); ok {
		r1 = rf(pair)
	} else {
		r1 = ret.Get(1).(float64)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string) error); ok {
		r2 = rf(pair)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Exchange_Position_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Position'
type Exchange_Position_Call struct {
	*mock.Call
}

// Position is a helper method to define mock.On call
//   - pair string
func (_e *Exchange_Expecter) Position(pair interface{}) *Exchange_Position_Call {
	return &Exchange_Position_Call{Call: _e.mock.On("Position", pair)}
}

func (_c *Exchange_Position_Call) Run(run func(pair string)) *Exchange_Position_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Exchange_Position_Call) Return(position model.Position, err error) *Exchange_Position_Call {
	_c.Call.Return(position, err)
	return _c
}

type mockConstructorTestingTNewExchange interface {
	mock.TestingT
	Cleanup(func())
}

// NewExchange creates a new instance of Exchange. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewExchange(t mockConstructorTestingTNewExchange) *Exchange {
	mock := &Exchange{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
